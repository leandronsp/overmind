#!/bin/sh
set -e

SOCK="$HOME/.overmind/overmind.sock"
SCRIPT="$0"
[ -L "$SCRIPT" ] && SCRIPT="$(readlink "$SCRIPT")"
DAEMON="$(cd "$(dirname "$SCRIPT")/.." && pwd)/overmind_daemon"
PIDFILE="$HOME/.overmind/daemon.pid"
LOGFILE="$HOME/.overmind/daemon.log"

# --- helpers ---

escape_json() {
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

send_cmd() {
  if [ ! -S "$SOCK" ]; then
    echo "Daemon not running. Start with: overmind start" >&2
    return 1
  fi
  response=$(printf '%s\n' "$1" | nc -U "$SOCK" 2>/dev/null) || {
    echo "Daemon not running. Start with: overmind start" >&2
    return 1
  }
  printf '%s' "$response"
}

extract_ok() {
  response="$1"
  if printf '%s' "$response" | grep -q '"error"'; then
    err=$(printf '%s' "$response" | sed 's/.*"error":"\([^"]*\)".*/\1/')
    echo "Error: $err" >&2
    return 1
  fi
  printf '%s' "$response" | sed 's/.*"ok":\(.*\)}/\1/' | sed 's/^"//; s/"$//'
}

unescape_json() {
  printf '%b' "$1"
}

# --- commands ---

cmd_start() {
  if [ -S "$SOCK" ]; then
    # verify daemon is actually alive by poking the socket
    if printf '{"cmd":"ping"}\n' | nc -U "$SOCK" >/dev/null 2>&1; then
      echo "Daemon is already running"
      return 0
    fi
    # stale socket — clean up
    rm -f "$SOCK" "$PIDFILE"
  fi

  mkdir -p "$(dirname "$SOCK")"
  nohup "$DAEMON" __daemon__ > "$LOGFILE" 2>&1 &
  daemon_pid=$!
  echo "$daemon_pid" > "$PIDFILE"

  # wait for socket
  i=0
  while [ $i -lt 20 ]; do
    if [ -S "$SOCK" ]; then
      echo "Daemon started (PID $daemon_pid)"
      return 0
    fi
    sleep 0.25
    i=$((i + 1))
  done
  echo "Daemon process started but not yet reachable"
}

cmd_shutdown() {
  response=$(send_cmd '{"cmd":"shutdown"}') || return 0
  # wait for socket removal
  i=0
  while [ $i -lt 20 ]; do
    [ ! -S "$SOCK" ] && break
    sleep 0.1
    i=$((i + 1))
  done
  rm -f "$PIDFILE"
  echo "Daemon stopped"
}

cmd_run() {
  command=""
  type="task"
  provider="raw"
  cwd=""
  name=""
  restart=""
  max_restarts=""
  backoff=""
  activity_timeout=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --type)             type="$2"; shift 2 ;;
      --provider)         provider="$2"; shift 2 ;;
      --cwd)              cwd="$2"; shift 2 ;;
      --name)             name="$2"; shift 2 ;;
      --restart)          restart="$2"; shift 2 ;;
      --max-restarts)     max_restarts="$2"; shift 2 ;;
      --backoff)          backoff="$2"; shift 2 ;;
      --activity-timeout) activity_timeout="$2"; shift 2 ;;
      *)                  command="$command $1"; shift ;;
    esac
  done
  command=$(echo "$command" | sed 's/^ //')

  if [ -z "$command" ] && [ "$type" = "task" ]; then
    echo "Missing command. Usage: overmind run <command>"
    return 1
  fi

  escaped=$(escape_json "$command")
  extra=""
  if [ -n "$cwd" ]; then
    ecwd=$(escape_json "$cwd")
    extra="$extra,\"cwd\":\"$ecwd\""
  fi
  if [ -n "$name" ]; then
    ename=$(escape_json "$name")
    extra="$extra,\"name\":\"$ename\""
  fi
  if [ -n "$restart" ]; then
    extra="$extra,\"restart\":\"$restart\""
  fi
  if [ -n "$max_restarts" ]; then
    extra="$extra,\"max_restarts\":$max_restarts"
  fi
  if [ -n "$backoff" ]; then
    extra="$extra,\"backoff\":$backoff"
  fi
  if [ -n "$activity_timeout" ]; then
    extra="$extra,\"activity_timeout\":$activity_timeout"
  fi
  json="{\"cmd\":\"run\",\"args\":{\"command\":\"$escaped\",\"type\":\"$type\",\"provider\":\"$provider\"$extra}}"
  response=$(send_cmd "$json") || return 1
  id=$(extract_ok "$response") || return 1
  echo "Started mission $id"
}

cmd_claude_run() {
  if [ $# -eq 0 ]; then
    echo "Missing prompt. Usage: overmind claude run <prompt>"
    return 1
  fi

  prompt="$*"
  escaped=$(escape_json "$prompt")
  json="{\"cmd\":\"run\",\"args\":{\"command\":\"$escaped\",\"type\":\"task\",\"provider\":\"claude\"}}"
  response=$(send_cmd "$json") || return 1
  id=$(extract_ok "$response") || return 1
  echo "Started mission $id"
}

cmd_ps() {
  response=$(send_cmd '{"cmd":"ps"}') || return 1
  text=$(extract_ok "$response") || return 1
  unescape_json "$text"
}

cmd_info() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"info\",\"args\":{\"id\":\"$escaped\"}}") || return 1
  if printf '%s' "$response" | grep -q '"error"'; then
    err=$(printf '%s' "$response" | sed 's/.*"error":"\([^"]*\)".*/\1/')
    echo "Error: $err" >&2
    return 1
  fi
  printf '%s\n' "$response" | sed 's/.*"ok"://' | sed 's/}$//'
}

cmd_logs() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"logs\",\"args\":{\"id\":\"$escaped\"}}") || return 1
  text=$(extract_ok "$response") || return 1
  unescape_json "$text"
}

cmd_stop() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"stop\",\"args\":{\"id\":\"$escaped\"}}") || return 1
  extract_ok "$response" > /dev/null || return 1
  echo "Stopped mission $id"
}

cmd_kill() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"kill\",\"args\":{\"id\":\"$escaped\"}}") || return 1
  extract_ok "$response" > /dev/null || return 1
  echo "Killed mission $id"
}

cmd_send() {
  id="$1"
  shift
  message="$*"
  eid=$(escape_json "$id")
  emsg=$(escape_json "$message")
  response=$(send_cmd "{\"cmd\":\"send\",\"args\":{\"id\":\"$eid\",\"message\":\"$emsg\"}}") || return 1
  extract_ok "$response" > /dev/null || return 1
  echo "Sent to mission $id"
}

cmd_detach() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"unpause\",\"args\":{\"id\":\"$escaped\"}}") || return 1
  extract_ok "$response" > /dev/null || return 1
  echo "Detached from mission $id"
}

cmd_attach() {
  id="$1"
  escaped=$(escape_json "$id")
  response=$(send_cmd "{\"cmd\":\"pause\",\"args\":{\"id\":\"$escaped\"}}") || return 1

  # Response is {"ok":{"session_id":"...","cwd":"..."}}
  session_id=$(printf '%s' "$response" | sed 's/.*"session_id":"\([^"]*\)".*/\1/')
  cwd=$(printf '%s' "$response" | sed 's/.*"cwd":"\([^"]*\)".*/\1/')

  # Check for error response
  if printf '%s' "$response" | grep -q '"error"'; then
    err=$(printf '%s' "$response" | sed 's/.*"error":"\([^"]*\)".*/\1/')
    echo "Error: $err" >&2
    return 1
  fi

  if [ "$session_id" = "null" ] || [ -z "$session_id" ]; then
    printf '{\"cmd\":\"unpause\",\"args\":{\"id\":\"%s\"}}\n' "$escaped" | nc -U "$SOCK" > /dev/null 2>&1
    echo "Mission $id has no session ID yet"
    return 1
  fi

  # unpause on exit (Ctrl+C, error, Claude exits)
  trap "printf '{\"cmd\":\"unpause\",\"args\":{\"id\":\"$escaped\"}}\\n' | nc -U \"$SOCK\" > /dev/null 2>&1" EXIT

  # cd to mission's working directory if set
  if [ -n "$cwd" ] && [ "$cwd" != "null" ]; then
    cd "$cwd" || true
  fi

  claude --resume "$session_id"
}

usage() {
  cat <<'EOF'
Overmind v0.1.0 — Kubernetes for AI Agents

Usage: overmind <command> [options]

Commands:
  start                    Start the daemon
  shutdown                 Stop the daemon
  run <command>            Spawn a raw command (task mode)
  run --type session       Spawn a session agent
  run --provider claude    Spawn with Claude provider
  run --cwd <path>         Set working directory
  run --name <name>        Set agent name (auto-generated if omitted)
  run --restart <policy>   Restart policy: never, on-failure, always
  run --max-restarts <n>   Max restart attempts (0 = unlimited, default 5)
  run --backoff <ms>       Base backoff in ms (default 1000, exponential)
  run --activity-timeout <s>  Kill after N seconds of no output (0 = disabled)
  claude run <prompt>      Spawn a Claude agent (task mode)
  send <id> <message>      Send a message to a session
  attach <id>              Attach to a session (TUI)
  detach <id>              Unpause after manual attach
  ps                       List all missions
  info <id>                Show mission info (os_pid, status, etc.)
  logs <id>                Show mission logs
  stop <id>                Stop a mission (SIGTERM)
  kill <id>                Kill a mission (SIGKILL)
EOF
}

# --- main ---

case "${1:-}" in
  start)       cmd_start ;;
  shutdown)    cmd_shutdown ;;
  run)         shift; cmd_run "$@" ;;
  claude)
    if [ "${2:-}" = "run" ]; then
      shift 2; cmd_claude_run "$@"
    else
      echo "Unknown command: claude $2"
      usage
    fi
    ;;
  ps)          cmd_ps ;;
  info)        cmd_info "$2" ;;
  logs)        cmd_logs "$2" ;;
  stop)        cmd_stop "$2" ;;
  kill)        cmd_kill "$2" ;;
  send)        shift; cmd_send "$@" ;;
  attach)      cmd_attach "$2" ;;
  detach)      cmd_detach "$2" ;;
  "")          usage ;;
  *)           echo "Unknown command: $1"; usage ;;
esac
